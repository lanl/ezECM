block1_members <- sample(1:p, size = nblock1, replace = FALSE)
block2_members <- (1:p)[-block1_members]
zero_elements <- expand.grid(block1_members, block2_members)
S[[k]][zero_elements$Var1, zero_elements$Var2] <- 0
S[[k]][zero_elements$Var2, zero_elements$Var1] <- 0
}
## data for kth class is drawn from a MVN, given the mean and covariance
Y[[k]] <- as.data.frame(LaplacesDemon::rmvn(n = N[k], mu = mu_use[,k], Sigma= S[[k]]))
## data is transformed to (0,1) using the logistic function to run a check
Ytemp<- 1/(1+ exp(-Y[[k]]))
## if machine precision causes the output of the logistic function to round to 1, the experiment is stopped
## this has never happened
if(max(apply(Ytemp,2,function(X){range(X)})) == 1){
stop()
}else{
Y[[k]]<- 1/(1+ exp(-Y[[k]]))
}
## a column for the event class is appended to the data.frame
Y[[k]] <- cbind(Y[[k]], as.character(k))
names(Y[[k]]) <- c(paste("p",as.character(1:p),  sep = ""), "event")
}
Y <- do.call("rbind", Y)
## A random sample of the data is taken to be the testing set
test_index <- sample(1:nrow(Y), size = Ntest)
testing <- Y[test_index,]
## The remainder is slated for training
training <- Y[-test_index, ]
## A random sample of the training set is set aside to have missing entries,
## the remainder is set aside to be the fully observed training set
train_full_index <- sample(1:nrow(training), size = Ntrain)
train_missing <- training[-train_full_index, ]
train_full <- training[train_full_index, ]
## If all event categories are not represented in the training set of full observations,
## the sampling scheme repeats
if(any(table(train_full$event) <= 1) | length(table(train_full$event)) <= (K-1)){
while(any(table(train_full$event) <= 1 | length(table(train_full$event)) <= (K-1))){
test_index <- sample(1:nrow(Y), size = Ntest)
testing <- Y[test_index,]
training <- Y[-test_index, ]
train_full_index <- sample(1:nrow(training), size = Ntrain)
train_missing <- training[-train_full_index, ]
train_full <- training[train_full_index, ]
}
}
## the true event category for the testing set is saved as a seperate variable,
## and deleted from the data.frame containing the data
test_truth <- testing$event
testing$event <- NULL
## Entries are randomly selected for deletion from the testing set.
## This scheme ensures a single discriminant for each observation
## not deleted in order to reduce computation time.
abs_present <- sample(size = Ntest, 1:p, replace = TRUE)
missing_pool <- matrix(1:p, ncol = p, nrow = Ntest, byrow = TRUE)
missing_pool <- t(apply(cbind(missing_pool, abs_present), 1, function(X,pp){
X[-c(X[pp + 1], pp +1)]
}, pp = p))
missing_pool_save <- missing_pool
frac_missing <- (p*tst_missing)/(p-1)
# sample which of the remaining elements will be missing
missing_sample <- sample(1:(nrow(missing_pool)*ncol(missing_pool)),
size = floor(nrow(missing_pool)*ncol(missing_pool)*(frac_missing)),
replace = FALSE)
missing_pool_save[missing_sample] <- NA
saved_data <- apply(cbind(missing_pool_save, unname(abs_present)), 1, function(X){
X[-which(is.na(X))]
})
for(j in 1:nrow(testing)){
testing[j,-c(saved_data[[j]])] <- NA
}
## Entries are randomly selected for deletion from the training set.
## This scheme ensures a single discriminant for each observation
## not deleted in order to reduce computation time.
abs_present <- sample(size = Ntrain_missing, 1:p, replace = TRUE)
abs_missing <- matrix(1:p, ncol = p, nrow = Ntrain_missing, byrow = TRUE)
abs_missing <- t(apply(cbind(abs_missing, abs_present), 1, function(X,pp){
X[-c(X[pp + 1], pp +1)]
}, pp = p))
abs_missing <- apply(abs_missing, 1, function(X){
sample(X, size = 1)
})
missing_pool <- matrix(1:p, ncol = p, nrow = Ntrain_missing, byrow = TRUE)
missing_pool <- t(apply(cbind(missing_pool, abs_present, abs_missing), 1, function(X,pp){
X[-c(X[pp + 1], X[pp + 2], pp +1, pp + 2)]
}, pp = p))
missing_pool_save <- missing_pool
frac_missing <- (p*trn_missing - 1)/(p-2)
# sample which of the remaining elements will be missing
missing_sample <- sample(1:(nrow(missing_pool)*ncol(missing_pool)), size = floor(nrow(missing_pool)*ncol(missing_pool)*(frac_missing)), replace = FALSE)
missing_pool_save[missing_sample] <- NA
saved_data <- apply(cbind(missing_pool_save, unname(abs_present)), 1, function(X){
X[-which(is.na(X))]
})
for(j in 1:nrow(train_missing)){
train_missing[j,-c(saved_data[[j]], p+1)] <- NA
}
return(list(Y = list(train_full = train_full, train_missing = train_missing,
testing = testing, test_truth = test_truth),
params = list(mu = mu_use, Sig = S, vic = vic)))
}
## Data Parameters
tst_missing <- 0.5
trn_missing <- 0.5
Ntrain <- 25
Ntest <- 100
Ntrain_missing <- 5 * Ntrain
K <- 3
P <- c(4,6)
#P <- c(4,6,8,10)
alpha <- 0.05
mixture_weights <- "training"
C01 <- matrix(c(0,1,1, 0), ncol = 2, nrow = 2)
C01
Cfneg <- C01
Cfneg[1,2] <- 2
Cfneg
Ccat <- matrix(1, ncol = 3, nrow = 3) - diag(3)
Ccat
iters <- 3#250
## MCMC parameters
BT <- c(150, 2150)
#BT <- c(500, 50500)
thinning <- 5
## Experimental Parameters
verb <- FALSE
#verb <- TRUE
## Data structures for saving progress
cecm_recfp <- cecm_recfn <- bayes_rec <- cecm_rec <- matrix(NA, ncol = length(P), nrow = iters)
Nvic <- rep(0, times = length(P))
exp_out <- list()
method_template <- data.frame(matrix(NA, ncol = 3, nrow = iters))
names(method_template) <- c("accurate", "FN", "FP")
data_template <- data.frame(matrix(NA, ncol = 2, nrow = iters))
names(data_template) <- c("Ntest", "Nvic")
data_template$Ntest <- Ntest
p_template <- list(cecm = method_template, becm = method_template,
mbecm = method_template, mbecm_Cfn = method_template,
mbecm_cat = method_template, data = data_template)
bayes_rec <- cecm_rec <- matrix(NA, ncol = length(P), nrow = iters)
if(verb){
toc <- Sys.time()
}
P
p <- 4
iters
i <- 1
exp_out[[p]] <- p_template
if(verb){
## set the experimental parameter verb <- TRUE to print progress
print(paste0("i = ", i, ", p = ", p, ", ", round(Sys.time() - toc, digits = 2), " ", units(Sys.time() - toc), " elapsed"))
}
## Generate random data set
Ylist <- data_gen(p = p, K = K, Ntest = Ntest, Ntrain = Ntrain,
Ntrain_missing = Ntrain_missing, tst_missing = tst_missing,
trn_missing = trn_missing)
## Saves the random data information to the environment
train_full<- Ylist$Y$train_full
train_missing <- Ylist$Y$train_missing
testing <- Ylist$Y$testing
test_truth <- Ylist$Y$test_truth
## Which category is the important one this time?
vic <- Ylist$params$vic
## Save the true total number of `vic` events in the testing data to be used
## later for analyzing performance.
exp_out[[p]][["data"]]$Nvic[i] <- sum(test_truth == as.character(vic))
## Fit the classical ECM model, apply the decision framework with the
## `cecm_decision()` function, then save the results
cecm <- p_agg(x = train_full, transform = TRUE, newdata = testing)
cecm_out <-  apply(cecm_decision(pval = cecm, alpha = alpha,
vic = as.character(vic),
cat_truth = test_truth)$events[,1:3] ,2,
sum, na.rm = TRUE)
exp_out[[p]][["cecm"]][i,] <- unname(cecm_out)
## Fit the B-ECM model, using only full p observations
bayes_fit <- BayesECM(Y = train_full)
## Run the predict function on the testing set.
## If there were multiple testing sets, the same model fit could be used on
## each one without having to rerun the `BayesECM()` function.  This
## functionality is more important when using training data with missing
## entries.
bayes_pred <- predict(bayes_fit, Ytilde = testing,
mixture_weights = mixture_weights)
## The "becm_desision()" function applies the decision theoretic framework
## to the training and testing data.  For one training and one testing set,
## where the user wants to try different values of `alpha` and `C`, it is
## not necessary to rerun the `BayesECM()` function or the `predict()`
## function.
becm_out <- becm_decision(bayes_pred = bayes_pred, alpha = alpha,
vic = as.character(vic), cat_truth = test_truth,
pn = TRUE, C = C01)
## Summarize and save the data.
becm_out <- apply(becm_out$results,2, sum, na.rm = TRUE)
exp_out[[p]][["becm"]][i,] <- unname(becm_out)
## Fit and save the B-ECM model that includes missing data
bayes_fit_missing <- BayesECM(Y = rbind(train_full, train_missing), BT = BT,
verb = verb)
bayes_pred_missing <- predict(bayes_fit_missing, Ytilde = testing,
thinning = thinning,
mixture_weights = mixture_weights)
missing_out <- becm_decision(bayes_pred = bayes_pred_missing, alpha = alpha,
vic = as.character(vic), cat_truth = test_truth,
pn = TRUE, C = C01)
mbecm_out <- apply(missing_out$results,2, sum, na.rm = TRUE)
exp_out[[p]][["mbecm"]][i,] <- unname(mbecm_out)
## The rest of the B-ECM variants are different through decision theory,
## not the model fit.  All use partial observations for training.
## Note that the rej argument is supplied to becm_decision to reduce computation time
## Record the decision when the loss matrix is adjusted to target
## false negatives.
Cfn_out <- becm_decision(bayes_pred = bayes_pred_missing, alpha = alpha,
vic = as.character(vic),
pn = TRUE, C = Cfneg, rej = missing_out$rej)
0.03*10000
0.03*20000
?data.frame
devtools::document()
devtools::document()
0.25*(9*4+8)
library(mixtools)
install.packages(mixtools)
install.packages("mixtools")
library(heplots)
library(ellipse)
?mvt
?dmvt
?df
?dbeta
library(tgp)
?tgp
X <- seq(0,1,length=50)
XX <- seq(0,1,length=99
Z <- 1 + 2*X + rnorm(length(X),sd=0.25)
XX <- seq(0,1,length=99)
Z <- 1 + 2*X + rnorm(length(X),sd=0.25)
?blm
in.gpllm <- bgpllm(X=X, XX=XX, Z=Z, BTE = c(250, 10000, 1))
in.gpllm
in.gpllm$Zp.mean
in.gpllm$ZZ.km
in.gpllm$ZZ.vark
in.gpllm$params
exp(-0.5)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(ezECM)
csv_use <- "good_training.csv"
file_path <- system.file("extdata", csv_use, package = "ezECM")
training_data <- import_pvals(file = file_path, header = TRUE, sep = ",", training = TRUE)
set.seed(1)
s1 <- sample(1:nrow(training_data), size = 25)
training_data[s1,1] <- NA
s2 <- sample((1:nrow(training_data))[-s1], size = 20)
training_data[s2,2] <- NA
s3 <- sample(1:nrow(training_data), size = 35)
training_data[s3,3] <- NA
training_data
BayesECM_fit <- BayesECM(Y = training_data, BT = c(1000, 40000))
csv_use <- "good_newdata.csv"
file_path <- system.file("extdata", csv_use, package = "ezECM")
newdata <- import_pvals(file = file_path, header = TRUE, sep = ",", training = FALSE)
newdata
newdata_truth <- newdata$event
newdata$event <- NULL
newdata[9,2:3] <- NA
cat_pred <- predict(object = BayesECM_fit, Ytilde = newdata, thinning = 2)
```{r}
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(ezECM)
csv_use <- "good_training.csv"
file_path <- system.file("extdata", csv_use, package = "ezECM")
training_data <- import_pvals(file = file_path, header = TRUE, sep = ",", training = TRUE)
set.seed(1)
s1 <- sample(1:nrow(training_data), size = 25)
training_data[s1,1] <- NA
s2 <- sample((1:nrow(training_data))[-s1], size = 20)
training_data[s2,2] <- NA
s3 <- sample(1:nrow(training_data), size = 35)
training_data[s3,3] <- NA
training_data
BayesECM_fit <- BayesECM(Y = training_data, BT = c(1000, 40000))
csv_use <- "good_newdata.csv"
file_path <- system.file("extdata", csv_use, package = "ezECM")
newdata <- import_pvals(file = file_path, header = TRUE, sep = ",", training = FALSE)
newdata
newdata_truth <- newdata$event
newdata$event <- NULL
newdata[9,2:3] <- NA
cat_pred <- predict(object = BayesECM_fit, Ytilde = newdata, thinning = 2)
plot(x = cat_pred, index = 5)
plot(x = cat_pred, index = 5)
?epzx
?apply
?colnames
knitr::opts_chunk$set(echo = FALSE)
## to try
### using "delta" instead of the value
### putting "delta" instead of parantheses
### color coding
tbl <- 6
load( paste0("synthetic_data_new_test", tbl, ".rda"))
P <- (1:length(exp_out))[-which(exp_out %in% list(NULL))]
tab_df <- data.frame(matrix(NA, ncol = length(P) + 1, nrow = 15))
tab_df[,1] <- rep(c("Accuracy", "False Negative", "False Positive"), times = 5)
tab_df_del <- del_df <- tab_df
Ntest <- 100
for(p in P){
pind <- which(P == p)
## C-ECM Accuracy
cecm_a_m <- mean(exp_out[[p]]$cecm$accurate)/Ntest
cecm_Na <- sum(exp_out[[p]]$cecm$accurate)
cecm_Nw <- Ntest*nrow(exp_out[[p]]$cecm) - cecm_Na
cecm_a_sd <- sqrt((cecm_Na*(1-cecm_a_m)^2 + cecm_Nw*(cecm_a_m)^2)/(cecm_Na + cecm_Nw -1))
tab_df[1,pind + 1] <- cecm_a_m#paste0(round(cecm_a_m, digits = 2), "(", round(cecm_a_sd, digits = 2), ")")
## B-ECM Accuracy
becm_a_m <- mean(exp_out[[p]]$becm$accurate)/Ntest
becm_Na <- sum(exp_out[[p]]$becm$accurate)
becm_Nw <- Ntest*nrow(exp_out[[p]]$becm) - becm_Na
becm_a_sd <- sqrt((becm_Na*(1-becm_a_m)^2 + becm_Nw*(becm_a_m)^2)/(becm_Na + becm_Nw -1))
tab_df[4,pind + 1] <- becm_a_m#paste0(round(becm_a_m, digits = 2), "(", round(becm_a_sd, digits = 2), ")")
tab_df_del[4, pind + 1] <- becm_a_m - cecm_a_m
## B-ECM Missing Accuracy
becm_a_m <- mean(exp_out[[p]]$becm_missing$accurate)/Ntest
becm_Na <- sum(exp_out[[p]]$becm_missing$accurate)
becm_Nw <- Ntest*nrow(exp_out[[p]]$becm_missing) - becm_Na
becm_a_sd <- sqrt((becm_Na*(1-becm_a_m)^2 + becm_Nw*(becm_a_m)^2)/(becm_Na + becm_Nw -1))
tab_df[7,pind + 1] <- becm_a_m#paste0(round(becm_a_m, digits = 2), "(", round(becm_a_sd, digits = 2), ")")
tab_df_del[7, pind + 1] <- becm_a_m - cecm_a_m
## B-ECM K_fn Accuracy
becm_a_m <- mean(exp_out[[p]]$becm_Cfn$accurate)/Ntest
becm_Na <- sum(exp_out[[p]]$becm_Cfn$accurate)
becm_Nw <- Ntest*nrow(exp_out[[p]]$becm_Cfn) - becm_Na
becm_a_sd <- sqrt((becm_Na*(1-becm_a_m)^2 + becm_Nw*(becm_a_m)^2)/(becm_Na + becm_Nw -1))
tab_df[10,pind + 1] <- becm_a_m#paste0(round(becm_a_m, digits = 2), "(", round(becm_a_sd, digits = 2), ")")
tab_df_del[10, pind + 1] <- becm_a_m - cecm_a_m
## B-ECM categorization Accuracy
becm_a_m <- mean(exp_out[[p]]$becm_cat$accurate)/Ntest
becm_Na <- sum(exp_out[[p]]$becm_cat$accurate)
becm_Nw <- Ntest*nrow(exp_out[[p]]$becm_cat) - becm_Na
becm_a_sd <- sqrt((becm_Na*(1-becm_a_m)^2 + becm_Nw*(becm_a_m)^2)/(becm_Na + becm_Nw -1))
tab_df[13,pind + 1] <- becm_a_m#paste0(round(becm_a_m, digits = 2), "(", round(becm_a_sd, digits = 2), ")")
tab_df_del[13, pind + 1] <- becm_a_m - cecm_a_m
## C-ECM False Negative
cecm_fn_m <- mean(exp_out[[p]]$cecm$FN/exp_out[[p]]$data$Nvic)
Na <- sum(exp_out[[p]]$cecm$FN)
Nw <- sum(exp_out[[p]]$data$Nvic) - Na
cecm_fn_sd <- sqrt((Na*(1-cecm_fn_m)^2 + Nw*(cecm_fn_m)^2)/(Na + Nw -1))
tab_df[2,pind + 1] <- cecm_fn_m#paste0(round(cecm_fn_m, digits = 2), "(", round(cecm_fn_sd, digits = 2), ")")
## B-ECM False Negative
becm_fn_m <- mean(exp_out[[p]]$becm$FN/exp_out[[p]]$data$Nvic)
Na <- sum(exp_out[[p]]$becm$FN)
Nw <- sum(exp_out[[p]]$data$Nvic) - Na
a <- rep(1, times = Na)
a <- c(a, rep(0, times = Nw))
becm_fn_sd <- sqrt((Na*(1-becm_fn_m)^2 + Nw*(becm_fn_m)^2)/(Na + Nw -1))
tab_df[5,pind + 1] <- becm_fn_m#paste0(round(becm_fn_m, digits = 2), "(", round(becm_fn_sd, digits = 2), ")")
tab_df_del[5,pind + 1] <- becm_fn_m - cecm_fn_m
## B-ECM Missing False Negative
becm_fn_m <- mean(exp_out[[p]]$becm_missing$FN/exp_out[[p]]$data$Nvic)
Na <- sum(exp_out[[p]]$becm_missing$FN)
Nw <- sum(exp_out[[p]]$data$Nvic) - Na
a <- rep(1, times = Na)
a <- c(a, rep(0, times = Nw))
becm_fn_sd <- sqrt((Na*(1-becm_fn_m)^2 + Nw*(becm_fn_m)^2)/(Na + Nw -1))
tab_df[8,pind + 1] <- becm_fn_m#paste0(round(becm_fn_m, digits = 2), "(", round(becm_fn_sd, digits = 2), ")")
tab_df_del[8,pind + 1] <- becm_fn_m - cecm_fn_m
## B-ECM Kfn False Negative
becm_fn_m <- mean(exp_out[[p]]$becm_Cfn$FN/exp_out[[p]]$data$Nvic)
Na <- sum(exp_out[[p]]$becm_Cfn$FN)
Nw <- sum(exp_out[[p]]$data$Nvic) - Na
a <- rep(1, times = Na)
a <- c(a, rep(0, times = Nw))
becm_fn_sd <- sqrt((Na*(1-becm_fn_m)^2 + Nw*(becm_fn_m)^2)/(Na + Nw -1))
tab_df[11,pind + 1] <- becm_fn_m#paste0(round(becm_fn_m, digits = 2), "(", round(becm_fn_sd, digits = 2), ")")
tab_df_del[11,pind + 1] <- becm_fn_m - cecm_fn_m
## B-ECM cat False Negative
becm_fn_m <- mean(exp_out[[p]]$becm_cat$FN/exp_out[[p]]$data$Nvic)
Na <- sum(exp_out[[p]]$becm_cat$FN)
Nw <- sum(exp_out[[p]]$data$Nvic) - Na
a <- rep(1, times = Na)
a <- c(a, rep(0, times = Nw))
becm_fn_sd <- sqrt((Na*(1-becm_fn_m)^2 + Nw*(becm_fn_m)^2)/(Na + Nw -1))
tab_df[14,pind + 1] <- becm_fn_m#paste0(round(becm_fn_m, digits = 2), "(", round(becm_fn_sd, digits = 2), ")")
tab_df_del[14,pind + 1] <- becm_fn_m - cecm_fn_m
## C-ECM False Positive
cecm_fp_m <- mean(exp_out[[p]]$cecm$FP/(Ntest - exp_out[[p]]$data$Nvic))
Na <- sum(exp_out[[p]]$cecm$FP)
Nw <- Ntest*nrow(exp_out[[p]]$cecm) - sum(exp_out[[p]]$data$Nvic) - Na
cecm_fp_sd <- sqrt((Na*(1-cecm_fp_m)^2 + Nw*(cecm_fp_m)^2)/(Na + Nw -1))
tab_df[3,pind + 1] <- cecm_fp_m #paste0(round(cecm_fp_m, digits = 2), "(", round(cecm_fp_sd, digits = 2), ")")
## B-ECM False Positive
becm_fp_m <- mean(exp_out[[p]]$becm$FP/(Ntest - exp_out[[p]]$data$Nvic))
Na <- sum(exp_out[[p]]$becm$FP)
Nw <- Ntest*nrow(exp_out[[p]]$becm) - sum(exp_out[[p]]$data$Nvic) - Na
becm_fp_sd <- sqrt((Na*(1-becm_fp_m)^2 + Nw*(becm_fp_m)^2)/(Na + Nw -1))
tab_df[6,pind + 1] <- becm_fp_m#paste0(round(becm_fp_m, digits = 2), "(", round(becm_fp_sd, digits = 2), ")")
tab_df_del[6, pind + 1] <- becm_fp_m - cecm_fp_m
## B-ECM Missing False Positive
becm_fp_m <- mean(exp_out[[p]]$becm_missing$FP/(Ntest - exp_out[[p]]$data$Nvic))
Na <- sum(exp_out[[p]]$becm_missing$FP)
Nw <- Ntest*nrow(exp_out[[p]]$becm_missing) - sum(exp_out[[p]]$data$Nvic) - Na
becm_fp_sd <- sqrt((Na*(1-becm_fp_m)^2 + Nw*(becm_fp_m)^2)/(Na + Nw -1))
tab_df[9,pind + 1] <- becm_fp_m#paste0(round(becm_fp_m, digits = 2), "(", round(becm_fp_sd, digits = 2), ")")
tab_df_del[9, pind + 1] <- becm_fp_m - cecm_fp_m
tab_df[,pind+1] <- round(tab_df[,pind + 1], digits = 2)
tab_df_del[,pind+1] <- round(tab_df_del[,pind + 1], digits = 2)
## B-ECM Kfn False Positive
becm_fp_m <- mean(exp_out[[p]]$becm_Cfn$FP/(Ntest - exp_out[[p]]$data$Nvic))
Na <- sum(exp_out[[p]]$becm_Cfn$FP)
Nw <- Ntest*nrow(exp_out[[p]]$becm_Cfn) - sum(exp_out[[p]]$data$Nvic) - Na
becm_fp_sd <- sqrt((Na*(1-becm_fp_m)^2 + Nw*(becm_fp_m)^2)/(Na + Nw -1))
tab_df[12,pind + 1] <- becm_fp_m#paste0(round(becm_fp_m, digits = 2), "(", round(becm_fp_sd, digits = 2), ")")
tab_df_del[12, pind + 1] <- becm_fp_m - cecm_fp_m
tab_df[,pind+1] <- round(tab_df[,pind + 1], digits = 2)
tab_df_del[,pind+1] <- round(tab_df_del[,pind + 1], digits = 2)
## B-ECM cat False Positive
becm_fp_m <- mean(exp_out[[p]]$becm_cat$FP/(Ntest - exp_out[[p]]$data$Nvic))
Na <- sum(exp_out[[p]]$becm_cat$FP)
Nw <- Ntest*nrow(exp_out[[p]]$becm_cat) - sum(exp_out[[p]]$data$Nvic) - Na
becm_fp_sd <- sqrt((Na*(1-becm_fp_m)^2 + Nw*(becm_fp_m)^2)/(Na + Nw -1))
tab_df[15,pind + 1] <- becm_fp_m#paste0(round(becm_fp_m, digits = 2), "(", round(becm_fp_sd, digits = 2), ")")
tab_df_del[15, pind + 1] <- becm_fp_m - cecm_fp_m
tab_df[,pind+1] <- round(tab_df[,pind + 1], digits = 2)
tab_df_del[,pind+1] <- round(tab_df_del[,pind + 1], digits = 2)
}
my_spec_color <- function (x, alpha = 1, begin = 0, end = 1, direction = 1, option = "D",
na_color = "#BBBBBB", scale_from = NULL)
{
if (is.null(scale_from)) {
lx <- length(x)
#x <- round(scales::rescale(c(x,-x), c(1, 256)))
x <- round(scales::rescale(c(x,-x), c(1, 5)))
x <- x[1:lx]
}
else {
lx <- length(x)
#x <- round(scales::rescale(c(x,-x), to = c(1, 256), from = scale_from))
x <- round(scales::rescale(c(x,-x), to = c(1, 5), from = scale_from))
x <- x[1:lx]
}
# if(direction == 1){
#   half_cols <- 257:512
# }else{
#   half_cols <- 1:256
# }
#color_code <- hcl.colors(256, palette = "Zissou1", alpha = alpha, rev = c(TRUE,FALSE)[direction])[x]
color_code <- hcl.colors(15, palette = "Zissou1", alpha = alpha, rev = c(TRUE,FALSE)[direction])[seq(from = 1, to = 15, length.out = 5)][x]
# color_code <- viridisLite::viridis(256, alpha, begin, end,
#     direction, option)[x]
color_code[is.na(color_code)] <- na_color
return(color_code)
}
col_dir <- c(1,2,2)
col_half <- c(1,2,1)
#col_dir <- c(2,1,1)
col_subsets <- matrix(1:15, ncol = 3, nrow = 5, byrow = TRUE)
col_subsets <- col_subsets[-1,]
for(i in 1:3){
xx <- as.numeric(as.vector(unlist(tab_df_del[col_subsets[,i],-1])))
#x <- as.vector(unlist(tab_df[col_subsets[,i],-1]))
#del_df[col_subsets[,i],-1] <- cell_spec(rep("$\\Delta$", times = length(xx)), color =  my_spec_color(xx, direction = col_dir[i]), escape = FALSE)
del_df[col_subsets[,i],-1] <- cell_spec(paste0(rep("$\\Delta$", times = length(xx)), xx), color =  my_spec_color(xx, direction = col_dir[i]), escape = FALSE)
}
for(p in P){
if(which(P == p) == 1){
boxplotdf <- cbind(exp_out[[p]]$cecm$accurate, exp_out[[p]]$becm$accurate, exp_out[[p]]$becm_missing$accurate, exp_out[[p]]$becm_Cfn$accurate, exp_out[[p]]$becm_cat$accurate)
}else{
boxplotdf <- cbind(boxplotdf, exp_out[[p]]$cecm$accurate, exp_out[[p]]$becm$accurate, exp_out[[p]]$becm_missing$accurate, exp_out[[p]]$becm_Cfn$accurate, exp_out[[p]]$becm_cat$accurate)
}
}
# name_vec <- rep("", times = length(P)*2)
# name_vec[seq(from = 1, to = length(P)*2 - 1, by = 2)] <- paste0("p = ", P)
pltcols <- hcl.colors(44, palette = "viridis", rev = TRUE)[c(1.5,5,10, 15, 18.5)*2 ]
par(mar = c(4.25,3.85,1,0.5))
boxplot(boxplotdf/100,  at = (1:(6*length(P)))[-seq(from = 6, to = length(P)*6, by = 6)],
xaxt = "n", yaxt = "n", ylim = c(min(boxplotdf)/100, 1.1),
col = pltcols, xlab = "Number of Discriminants", ylab = "Model Accuracy")
str(boxplotdf)
?boxplot
P
(1:(6*length(P)))[-seq(from = 6, to = length(P)*6, by = 6)]
str((1:(6*length(P)))[-seq(from = 6, to = length(P)*6, by = 6)])
boxplotdf[100,]
boxplotdf[1:100,]
p
exp_out[[p]]$cecm$accurate
P
p <- 4
exp_out[[p]]$cecm$accurate
exp_out[[p]]$becm$accurate
for(p in P){
if(which(P == p) == 1){
boxplotdf <- cbind(exp_out[[p]]$cECM$accurate, exp_out[[p]]$becm$accurate, exp_out[[p]]$becm_missing$accurate, exp_out[[p]]$becm_Cfn$accurate, exp_out[[p]]$becm_cat$accurate)
}else{
boxplotdf <- cbind(boxplotdf, exp_out[[p]]$cECM$accurate, exp_out[[p]]$becm$accurate, exp_out[[p]]$becm_missing$accurate, exp_out[[p]]$becm_Cfn$accurate, exp_out[[p]]$becm_cat$accurate)
}
}
# name_vec <- rep("", times = length(P)*2)
# name_vec[seq(from = 1, to = length(P)*2 - 1, by = 2)] <- paste0("p = ", P)
pltcols <- hcl.colors(44, palette = "viridis", rev = TRUE)[c(1.5,5,10, 15, 18.5)*2 ]
par(mar = c(4.25,3.85,1,0.5))
boxplot(boxplotdf/100,  at = (1:(6*length(P)))[-seq(from = 6, to = length(P)*6, by = 6)],
xaxt = "n", yaxt = "n", ylim = c(min(boxplotdf)/100, 1.1),
col = pltcols, xlab = "Number of Discriminants", ylab = "Model Accuracy")
py <- pretty(boxplotdf/100)
axis(2, py)
axis(1, at =seq(from = 1, to = length(P)*6, by = 6) + 1, labels =  paste0("p = ", P) )
legend("topleft", bty ="n", legend = c("C-ECM", "B-ECM", "M-B-ECM", bquote("M-B-ECM, " * C["1,2"] == 2), "M-B-ECM Cat"), fill = pltcols, horiz = FALSE, ncol = 3, y.intersp = 1.25)
devtools::build_manual()
