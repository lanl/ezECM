pltcols <- hcl.colors(44, palette = "viridis", rev = TRUE)[seq(from = 2, to = 38, length.out = length(models))]
}
}else{
if(length(cols) != length(models)){
stop("If supplying colors, a vector the same length as the 'models' argument must be used.")
}
}
opar <- par()
on.exit(expr = suppressWarnings(par(opar)))
par(mar = c(4.25,3.85,1,0.5))
lmodels <- length(models)
graphics::boxplot(boxplotdf/100,
at = (1:((lmodels + 1)*length(P)))[-seq(from = lmodels + 1,
to = length(P)*(lmodels + 1),
by = lmodels + 1)],
xaxt = "n", yaxt = "n", ylim = c(min(boxplotdf)/100, 1.1),
col = pltcols, xlab = "Number of Discriminants", ylab = ylab)
py <- pretty(boxplotdf/100)
graphics::axis(2, py)
graphics::axis(1, at =seq(from = 1, to = length(P)*(lmodels + 1), by = lmodels + 1) + 1,
labels =  paste0("p = ", P) )
graphics::legend("topleft", bty ="n",
legend = legend_text,
fill = pltcols, horiz = FALSE, ncol = 3, y.intersp = 1.25)
}
ECM_boxplot(exp_out = exp_out, P = P, metric = "FN")
ECM_boxplot(exp_out = exp_out, P = P, metric = "FP")
ECM_boxplot(exp_out = exp_out, P = P, metric = "FN")
range(boxplotdfg)
ECM_boxplot <- function(exp_out, P = P, models = c("cecm", "becm",
"mbecm",
"mbecm_Cfn",
"mbecm_cat"),
cols = NULL,
legend_text =  c("C-ECM", "B-ECM", "M-B-ECM",
bquote("M-B-ECM, " * C["1,2"] == 2), "M-B-ECM Cat"),
metric = "accurate"){
if(metric == "accurate"){
divisor <- function(exp_out, p){
return(exp_out[[p]]$data$Ntest)
}
ylab <- "Model Accuracy"
}else if(metric == "FN"){
divisor <- function(exp_out,p){
return(exp_out[[p]]$data$Nvic)
}
ylab <- "False Negative Rate"
}else if(metric == "FP"){
divisor <- function(exp_out, p){
return(exp_out[[p]]$data$Ntest - exp_out[[p]]$data$Nvic)
}
ylab <- "False Positive Rate"
}else{
stop("Argument 'metric' must be one of the following case sensitive character strings: 'accurate', 'FN', or 'FP'.")
}
boxplotdf <- do.call("cbind", lapply(exp_out[[P[1]]][models], function(X, m = metric){
X[[m]]
}))/divisor(exp_out, p = P[1])
for(p in P[-1]){
boxplotdf <- cbind(boxplotdf,do.call("cbind", lapply(exp_out[[p]][models], function(X, m = metric){
X[[m]]
}))/divisor(exp_out, p = p))
}
boxplotdf <- boxplotdf * 100
if(max(boxplotdf) > 65){
ylim <- c(min(boxplotdf)/100, 1.1)
}else{
ylim <- range(boxplotdf)
}
if(is.null(cols)){
if(length(models) == 5){
pltcols <- hcl.colors(44, palette = "viridis", rev = TRUE)[c(3, 10, 20, 30, 37)]
}else if(length(models) > 10){
warning("You should consider recoding this function with a different way to select the colors used for the plot.")
pltcols <- hcl.colors(44, palette = "viridis", rev = TRUE)[seq(from = 2, to = 38, length.out = length(models))]
}else{
pltcols <- hcl.colors(44, palette = "viridis", rev = TRUE)[seq(from = 2, to = 38, length.out = length(models))]
}
}else{
if(length(cols) != length(models)){
stop("If supplying colors, a vector the same length as the 'models' argument must be used.")
}
}
opar <- par()
on.exit(expr = suppressWarnings(par(opar)))
par(mar = c(4.25,3.85,1,0.5))
lmodels <- length(models)
graphics::boxplot(boxplotdf/100,
at = (1:((lmodels + 1)*length(P)))[-seq(from = lmodels + 1,
to = length(P)*(lmodels + 1),
by = lmodels + 1)],
xaxt = "n", yaxt = "n", ylim = ylim,
col = pltcols, xlab = "Number of Discriminants", ylab = ylab)
py <- pretty(boxplotdf/100)
graphics::axis(2, py)
graphics::axis(1, at =seq(from = 1, to = length(P)*(lmodels + 1), by = lmodels + 1) + 1,
labels =  paste0("p = ", P) )
graphics::legend("topleft", bty ="n",
legend = legend_text,
fill = pltcols, horiz = FALSE, ncol = 3, y.intersp = 1.25)
}
ECM_boxplot(exp_out = exp_out, P = P, metric = "FN")
ECM_boxplot(exp_out = exp_out, P = P, metric = "FP")
ECM_boxplot <- function(exp_out, P = P, models = c("cecm", "becm",
"mbecm",
"mbecm_Cfn",
"mbecm_cat"),
cols = NULL,
legend_text =  c("C-ECM", "B-ECM", "M-B-ECM",
bquote("M-B-ECM, " * C["1,2"] == 2), "M-B-ECM Cat"),
metric = "accurate"){
if(metric == "accurate"){
divisor <- function(exp_out, p){
return(exp_out[[p]]$data$Ntest)
}
ylab <- "Model Accuracy"
}else if(metric == "FN"){
divisor <- function(exp_out,p){
return(exp_out[[p]]$data$Nvic)
}
ylab <- "False Negative Rate"
}else if(metric == "FP"){
divisor <- function(exp_out, p){
return(exp_out[[p]]$data$Ntest - exp_out[[p]]$data$Nvic)
}
ylab <- "False Positive Rate"
}else{
stop("Argument 'metric' must be one of the following case sensitive character strings: 'accurate', 'FN', or 'FP'.")
}
boxplotdf <- do.call("cbind", lapply(exp_out[[P[1]]][models], function(X, m = metric){
X[[m]]
}))/divisor(exp_out, p = P[1])
for(p in P[-1]){
boxplotdf <- cbind(boxplotdf,do.call("cbind", lapply(exp_out[[p]][models], function(X, m = metric){
X[[m]]
}))/divisor(exp_out, p = p))
}
boxplotdf <- boxplotdf * 100
boxplotdfg <<- boxplotdf
if(max(boxplotdf) > 65){
ylim <- c(min(boxplotdf)/100, 1.1)
}else{
ylim <- range(boxplotdf)
}
if(is.null(cols)){
if(length(models) == 5){
pltcols <- hcl.colors(44, palette = "viridis", rev = TRUE)[c(3, 10, 20, 30, 37)]
}else if(length(models) > 10){
warning("You should consider recoding this function with a different way to select the colors used for the plot.")
pltcols <- hcl.colors(44, palette = "viridis", rev = TRUE)[seq(from = 2, to = 38, length.out = length(models))]
}else{
pltcols <- hcl.colors(44, palette = "viridis", rev = TRUE)[seq(from = 2, to = 38, length.out = length(models))]
}
}else{
if(length(cols) != length(models)){
stop("If supplying colors, a vector the same length as the 'models' argument must be used.")
}
}
opar <- par()
on.exit(expr = suppressWarnings(par(opar)))
par(mar = c(4.25,3.85,1,0.5))
lmodels <- length(models)
graphics::boxplot(boxplotdf/100,
at = (1:((lmodels + 1)*length(P)))[-seq(from = lmodels + 1,
to = length(P)*(lmodels + 1),
by = lmodels + 1)],
xaxt = "n", yaxt = "n", ylim = ylim,
col = pltcols, xlab = "Number of Discriminants", ylab = ylab)
py <- pretty(boxplotdf/100)
graphics::axis(2, py)
graphics::axis(1, at =seq(from = 1, to = length(P)*(lmodels + 1), by = lmodels + 1) + 1,
labels =  paste0("p = ", P) )
graphics::legend("topleft", bty ="n",
legend = legend_text,
fill = pltcols, horiz = FALSE, ncol = 3, y.intersp = 1.25)
}
ECM_boxplot(exp_out = exp_out, P = P, metric = "FP")
boxplotdfg
range(boxplotdfg)
boxplotdf <- boxplotdfg
if(max(boxplotdf) > 65){
ylim <- c(min(boxplotdf)/100, 1.1)
}else{
ylim <- range(boxplotdf)
}
ylim
lmodels <- length(models)
models = c("cecm", "becm",
"mbecm",
"mbecm_Cfn",
"mbecm_cat")
lmodels <- length(models)
graphics::boxplot(boxplotdf/100,
at = (1:((lmodels + 1)*length(P)))[-seq(from = lmodels + 1,
to = length(P)*(lmodels + 1),
by = lmodels + 1)],
xaxt = "n", yaxt = "n", ylim = ylim,
col = pltcols, xlab = "Number of Discriminants", ylab = ylab)
ylab <- "False Positive Rate"
par(mar = c(4.25,3.85,1,0.5))
lmodels <- length(models)
graphics::boxplot(boxplotdf/100,
at = (1:((lmodels + 1)*length(P)))[-seq(from = lmodels + 1,
to = length(P)*(lmodels + 1),
by = lmodels + 1)],
xaxt = "n", yaxt = "n", ylim = ylim,
col = pltcols, xlab = "Number of Discriminants", ylab = ylab)
pltcols <- hcl.colors(44, palette = "viridis", rev = TRUE)[c(3, 10, 20, 30, 37)]
graphics::boxplot(boxplotdf/100,
at = (1:((lmodels + 1)*length(P)))[-seq(from = lmodels + 1,
to = length(P)*(lmodels + 1),
by = lmodels + 1)],
xaxt = "n", yaxt = "n", ylim = ylim,
col = pltcols, xlab = "Number of Discriminants", ylab = ylab)
ylim
ECM_boxplot <- function(exp_out, P = P, models = c("cecm", "becm",
"mbecm",
"mbecm_Cfn",
"mbecm_cat"),
cols = NULL,
legend_text =  c("C-ECM", "B-ECM", "M-B-ECM",
bquote("M-B-ECM, " * C["1,2"] == 2), "M-B-ECM Cat"),
metric = "accurate"){
if(metric == "accurate"){
divisor <- function(exp_out, p){
return(exp_out[[p]]$data$Ntest)
}
ylab <- "Model Accuracy"
}else if(metric == "FN"){
divisor <- function(exp_out,p){
return(exp_out[[p]]$data$Nvic)
}
ylab <- "False Negative Rate"
}else if(metric == "FP"){
divisor <- function(exp_out, p){
return(exp_out[[p]]$data$Ntest - exp_out[[p]]$data$Nvic)
}
ylab <- "False Positive Rate"
}else{
stop("Argument 'metric' must be one of the following case sensitive character strings: 'accurate', 'FN', or 'FP'.")
}
boxplotdf <- do.call("cbind", lapply(exp_out[[P[1]]][models], function(X, m = metric){
X[[m]]
}))/divisor(exp_out, p = P[1])
for(p in P[-1]){
boxplotdf <- cbind(boxplotdf,do.call("cbind", lapply(exp_out[[p]][models], function(X, m = metric){
X[[m]]
}))/divisor(exp_out, p = p))
}
boxplotdf <- boxplotdf * 100
boxplotdfg <<- boxplotdf
if(max(boxplotdf) > 65){
ylim <- c(min(boxplotdf)/100, 1.1)
}else{
ylim <- range(boxplotdf)/100
}
if(is.null(cols)){
if(length(models) == 5){
pltcols <- hcl.colors(44, palette = "viridis", rev = TRUE)[c(3, 10, 20, 30, 37)]
}else if(length(models) > 10){
warning("You should consider recoding this function with a different way to select the colors used for the plot.")
pltcols <- hcl.colors(44, palette = "viridis", rev = TRUE)[seq(from = 2, to = 38, length.out = length(models))]
}else{
pltcols <- hcl.colors(44, palette = "viridis", rev = TRUE)[seq(from = 2, to = 38, length.out = length(models))]
}
}else{
if(length(cols) != length(models)){
stop("If supplying colors, a vector the same length as the 'models' argument must be used.")
}
}
opar <- par()
on.exit(expr = suppressWarnings(par(opar)))
par(mar = c(4.25,3.85,1,0.5))
lmodels <- length(models)
graphics::boxplot(boxplotdf/100,
at = (1:((lmodels + 1)*length(P)))[-seq(from = lmodels + 1,
to = length(P)*(lmodels + 1),
by = lmodels + 1)],
xaxt = "n", yaxt = "n", ylim = ylim,
col = pltcols, xlab = "Number of Discriminants", ylab = ylab)
py <- pretty(boxplotdf/100)
graphics::axis(2, py)
graphics::axis(1, at =seq(from = 1, to = length(P)*(lmodels + 1), by = lmodels + 1) + 1,
labels =  paste0("p = ", P) )
graphics::legend("topleft", bty ="n",
legend = legend_text,
fill = pltcols, horiz = FALSE, ncol = 3, y.intersp = 1.25)
}
ECM_boxplot(exp_out = exp_out, P = P, metric = "FP")
ECM_boxplot <- function(exp_out, P = P, models = c("cecm", "becm",
"mbecm",
"mbecm_Cfn",
"mbecm_cat"),
cols = NULL,
legend_text =  c("C-ECM", "B-ECM", "M-B-ECM",
bquote("M-B-ECM, " * C["1,2"] == 2), "M-B-ECM Cat"),
metric = "accurate"){
if(metric == "accurate"){
divisor <- function(exp_out, p){
return(exp_out[[p]]$data$Ntest)
}
ylab <- "Model Accuracy"
}else if(metric == "FN"){
divisor <- function(exp_out,p){
return(exp_out[[p]]$data$Nvic)
}
ylab <- "False Negative Rate"
}else if(metric == "FP"){
divisor <- function(exp_out, p){
return(exp_out[[p]]$data$Ntest - exp_out[[p]]$data$Nvic)
}
ylab <- "False Positive Rate"
}else{
stop("Argument 'metric' must be one of the following case sensitive character strings: 'accurate', 'FN', or 'FP'.")
}
boxplotdf <- do.call("cbind", lapply(exp_out[[P[1]]][models], function(X, m = metric){
X[[m]]
}))/divisor(exp_out, p = P[1])
for(p in P[-1]){
boxplotdf <- cbind(boxplotdf,do.call("cbind", lapply(exp_out[[p]][models], function(X, m = metric){
X[[m]]
}))/divisor(exp_out, p = p))
}
boxplotdf <- boxplotdf * 100
boxplotdfg <<- boxplotdf
if(max(boxplotdf) > 65){
ylim <- c(min(boxplotdf)/100, 1.1)
}else{
ylim <- range(boxplotdf)/100 * c(0.9,1.1)
}
if(is.null(cols)){
if(length(models) == 5){
pltcols <- hcl.colors(44, palette = "viridis", rev = TRUE)[c(3, 10, 20, 30, 37)]
}else if(length(models) > 10){
warning("You should consider recoding this function with a different way to select the colors used for the plot.")
pltcols <- hcl.colors(44, palette = "viridis", rev = TRUE)[seq(from = 2, to = 38, length.out = length(models))]
}else{
pltcols <- hcl.colors(44, palette = "viridis", rev = TRUE)[seq(from = 2, to = 38, length.out = length(models))]
}
}else{
if(length(cols) != length(models)){
stop("If supplying colors, a vector the same length as the 'models' argument must be used.")
}
}
opar <- par()
on.exit(expr = suppressWarnings(par(opar)))
par(mar = c(4.25,3.85,1,0.5))
lmodels <- length(models)
graphics::boxplot(boxplotdf/100,
at = (1:((lmodels + 1)*length(P)))[-seq(from = lmodels + 1,
to = length(P)*(lmodels + 1),
by = lmodels + 1)],
xaxt = "n", yaxt = "n", ylim = ylim,
col = pltcols, xlab = "Number of Discriminants", ylab = ylab)
py <- pretty(boxplotdf/100)
graphics::axis(2, py)
graphics::axis(1, at =seq(from = 1, to = length(P)*(lmodels + 1), by = lmodels + 1) + 1,
labels =  paste0("p = ", P) )
graphics::legend("topleft", bty ="n",
legend = legend_text,
fill = pltcols, horiz = FALSE, ncol = 3, y.intersp = 1.25)
}
ECM_boxplot(exp_out = exp_out, P = P, metric = "FP")
ECM_boxplot <- function(exp_out, P = P, models = c("cecm", "becm",
"mbecm",
"mbecm_Cfn",
"mbecm_cat"),
cols = NULL,
legend_text =  c("C-ECM", "B-ECM", "M-B-ECM",
bquote("M-B-ECM, " * C["1,2"] == 2), "M-B-ECM Cat"),
metric = "accurate"){
if(metric == "accurate"){
divisor <- function(exp_out, p){
return(exp_out[[p]]$data$Ntest)
}
ylab <- "Model Accuracy"
}else if(metric == "FN"){
divisor <- function(exp_out,p){
return(exp_out[[p]]$data$Nvic)
}
ylab <- "False Negative Rate"
}else if(metric == "FP"){
divisor <- function(exp_out, p){
return(exp_out[[p]]$data$Ntest - exp_out[[p]]$data$Nvic)
}
ylab <- "False Positive Rate"
}else{
stop("Argument 'metric' must be one of the following case sensitive character strings: 'accurate', 'FN', or 'FP'.")
}
boxplotdf <- do.call("cbind", lapply(exp_out[[P[1]]][models], function(X, m = metric){
X[[m]]
}))/divisor(exp_out, p = P[1])
for(p in P[-1]){
boxplotdf <- cbind(boxplotdf,do.call("cbind", lapply(exp_out[[p]][models], function(X, m = metric){
X[[m]]
}))/divisor(exp_out, p = p))
}
boxplotdf <- boxplotdf * 100
boxplotdfg <<- boxplotdf
if(max(boxplotdf) > 65){
ylim <- c(min(boxplotdf)/100, 1.1)
}else{
ylim <- range(boxplotdf)/100 * c(0.9,1.2)
}
if(is.null(cols)){
if(length(models) == 5){
pltcols <- hcl.colors(44, palette = "viridis", rev = TRUE)[c(3, 10, 20, 30, 37)]
}else if(length(models) > 10){
warning("You should consider recoding this function with a different way to select the colors used for the plot.")
pltcols <- hcl.colors(44, palette = "viridis", rev = TRUE)[seq(from = 2, to = 38, length.out = length(models))]
}else{
pltcols <- hcl.colors(44, palette = "viridis", rev = TRUE)[seq(from = 2, to = 38, length.out = length(models))]
}
}else{
if(length(cols) != length(models)){
stop("If supplying colors, a vector the same length as the 'models' argument must be used.")
}
}
opar <- par()
on.exit(expr = suppressWarnings(par(opar)))
par(mar = c(4.25,3.85,1,0.5))
lmodels <- length(models)
graphics::boxplot(boxplotdf/100,
at = (1:((lmodels + 1)*length(P)))[-seq(from = lmodels + 1,
to = length(P)*(lmodels + 1),
by = lmodels + 1)],
xaxt = "n", yaxt = "n", ylim = ylim,
col = pltcols, xlab = "Number of Discriminants", ylab = ylab)
py <- pretty(boxplotdf/100)
graphics::axis(2, py)
graphics::axis(1, at =seq(from = 1, to = length(P)*(lmodels + 1), by = lmodels + 1) + 1,
labels =  paste0("p = ", P) )
graphics::legend("topleft", bty ="n",
legend = legend_text,
fill = pltcols, horiz = FALSE, ncol = 3, y.intersp = 1.25)
}
ECM_boxplot(exp_out = exp_out, P = P, metric = "FP")
ECM_boxplot <- function(exp_out, P = P, models = c("cecm", "becm",
"mbecm",
"mbecm_Cfn",
"mbecm_cat"),
cols = NULL,
legend_text =  c("C-ECM", "B-ECM", "M-B-ECM",
bquote("M-B-ECM, " * C["1,2"] == 2), "M-B-ECM Cat"),
metric = "accurate"){
if(metric == "accurate"){
divisor <- function(exp_out, p){
return(exp_out[[p]]$data$Ntest)
}
ylab <- "Model Accuracy"
}else if(metric == "FN"){
divisor <- function(exp_out,p){
return(exp_out[[p]]$data$Nvic)
}
ylab <- "False Negative Rate"
}else if(metric == "FP"){
divisor <- function(exp_out, p){
return(exp_out[[p]]$data$Ntest - exp_out[[p]]$data$Nvic)
}
ylab <- "False Positive Rate"
}else{
stop("Argument 'metric' must be one of the following case sensitive character strings: 'accurate', 'FN', or 'FP'.")
}
boxplotdf <- do.call("cbind", lapply(exp_out[[P[1]]][models], function(X, m = metric){
X[[m]]
}))/divisor(exp_out, p = P[1])
for(p in P[-1]){
boxplotdf <- cbind(boxplotdf,do.call("cbind", lapply(exp_out[[p]][models], function(X, m = metric){
X[[m]]
}))/divisor(exp_out, p = p))
}
boxplotdf <- boxplotdf
if(max(boxplotdf) > 65){
ylim <- c(min(boxplotdf), 1.1)
}else{
ylim <- range(boxplotdf) * c(0.9,1.2)
}
if(is.null(cols)){
if(length(models) == 5){
pltcols <- hcl.colors(44, palette = "viridis", rev = TRUE)[c(3, 10, 20, 30, 37)]
}else if(length(models) > 10){
warning("You should consider recoding this function with a different way to select the colors used for the plot.")
pltcols <- hcl.colors(44, palette = "viridis", rev = TRUE)[seq(from = 2, to = 38, length.out = length(models))]
}else{
pltcols <- hcl.colors(44, palette = "viridis", rev = TRUE)[seq(from = 2, to = 38, length.out = length(models))]
}
}else{
if(length(cols) != length(models)){
stop("If supplying colors, a vector the same length as the 'models' argument must be used.")
}
}
opar <- par()
on.exit(expr = suppressWarnings(par(opar)))
par(mar = c(4.25,3.85,1,0.5))
lmodels <- length(models)
graphics::boxplot(boxplotdf,
at = (1:((lmodels + 1)*length(P)))[-seq(from = lmodels + 1,
to = length(P)*(lmodels + 1),
by = lmodels + 1)],
xaxt = "n", yaxt = "n", ylim = ylim,
col = pltcols, xlab = "Number of Discriminants", ylab = ylab)
py <- pretty(boxplotdf)
graphics::axis(2, py)
graphics::axis(1, at =seq(from = 1, to = length(P)*(lmodels + 1), by = lmodels + 1) + 1,
labels =  paste0("p = ", P) )
graphics::legend("topleft", bty ="n",
legend = legend_text,
fill = pltcols, horiz = FALSE, ncol = 3, y.intersp = 1.25)
}
ECM_boxplot(exp_out = exp_out, P = P, metric = "FP")
ECM_boxplot(exp_out = exp_out, P = P, metric = "FN")
ECM_boxplot(exp_out = exp_out, P = P, metric = "accurate")
